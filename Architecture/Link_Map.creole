<<import head.html Architecture - Link Map>>

<<crumbs Architecture -> Link Map>>
<<TOC>>

= Link Map
The link map is Imperial's system for representing how all the data in the system connects together. It's both a caching system and a way to represent references (both implicit and explicit). Exchange also uses the links to determine which data of a reference group should be exported and which can be derived from the exported data (so as to reduce duplication in the export).

The cache invalidation system exists for two purposes: reimporting from an altered source (thus changing dynamic data) and allowing applications to alter data at will. In this way, it's a system to make Imperial reactive.

== Things that are linked
* A source file (such as a binary) and its entry node(s) in memory.
** This is likely done thru a node for the packed form, so source <-> packed <-> keys.
* A referrant and all explicit references to it.
** This can be list indices and basic values, as well as keys.
* An inherited value and the key it inherited from.
* A donor's static data and all its clones'.
* A calculated value and all contributors to that value.
* A parent's packed form and all its children's.
* A whole struct and whole form conversions of it.
** For example, graphic -> png.
* Links between data and an applications use of it, if the application requests it.

== Ways things are linked
Often times, a link doesn't have equivalent data of the same type on both ends. There is generally some conversion being made. In this case, the link map must be aware of the implications of that conversion. It can be:

* reversible: lossless, one-to-one translation.
* recoverable: 100% quality but not bit-for-bit the same, e.g. ordering being lost.
* lossy: lost quality, but can be reversed anyway, such as ogg -> mp3.
* irreversible: the translation is one-way, and cannot be recovered into a useful state when reversed.

For instance, if you query a MIDI-type struct for how many A notes it has, this is irreversible (it cannot recreate the MIDI data from knowing how many A notes it has, though it can perhaps validate it). But if you have a conversion from number to string (with no formatting), it's reversible.

== Common links
When writing a description for a binary files, the position information is often implied. That is, it defaults to referencing the previous sister's end (or parent's base if no sister) or 0:b if it's the first struct in the root or a new binary context. In the referential cases, it establishes a link the same as if it was an explicit reference.

When a struct references into another struct which has been cloned, it forces clones of itself in a 1:1 manner. So if B references into A and is cloned in this way, then: A,,0,, and B,,0,, are linked, A,,1,, and B,,1,, are linked, etc. A is also linked to A,,0..N,, but A,,0,, has no association with A,,1,, or B,,1,,.

== Reference groups
When multiple keys (for example) reference a single target, they and the target join what's called a reference group. These groups have special cache invalidation rules compared to the typical 1:1 links.

When a member of the group which is not the target is invalidated, the target is invalidated, but not the other members. When the target is updated, it invalidates all members besides itself. When the target is requested but does not have a value, it can interpret the value from the reference group members only if all members who have a value will convert to the same value (it is an error if they have divergent values, in this situation). When a member does not have a value, they must retrieve it through the target (which can infer it from other members). Similar to this pseudocode:

<<code python
def target_invalidated_or_updated(target, members):
	for member in members:
		member.invalidate()

def member_invalidated_or_updated(member, target, other_members):
	target.invalidate()

# Note that these following two functions do not cause invalidations.
def get_target_value(target, members):
	if not target.has_value:
		for member in members:
			if member.has_value:
				value = target.convert_value_from(member)
				if target.has_value:
					assert value == target.value
				target.value = value
	return target.value

def get_member_value(member, target, other_members):
	if not member.has_value:
		value = get_target_value(target, other_members)
		member.value = member.convert_value(value)
	return member.value
>>

References to references chain rather than get absorbed. For instance, in the case of something like:
<<code mprl
static Example {
	a: 1
	b: @this.a
	c: @this.a
	d: @this.b
	e: @this.b
}
>>
These keys do not enter into a single reference group, but two. ##{a, b, c}## and ##{b, d, e}##. This way, if this were a dynamic and //b// required some sort of conversion, //d// and //e// know to convert from //b// and not from, for example, //c// which might convert differently.

Explicit, circular references are disallowed; at least for now. If the are implemented, they should error if the end of the cycle does not convert to the same value as the first. Likely, they could not be lazily evaluated.

<<import foot.html>>
